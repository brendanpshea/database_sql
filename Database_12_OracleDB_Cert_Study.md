Oracle Database Foundations Study Guide

The Oracle Database Foundations Exam (Number: 1Z0-006) is a globally recognized qualification that can validate your skills in the eyes of potential employers and give you an edge in the increasingly competitive field of data management. It tests your understanding of key concepts, practical skills, and best practices in designing, implementing, and managing Oracle (and other RDBMS) databases. You can register for the exam here: <https://education.oracle.com/oracle-database-foundations-novice-level-exam/pexam_1Z0-006>.

**Taking this exam is optional!** However, the final exam for this class will ALSO be based on the content here (which pulls together much of what we've been learning over the course of the semester).

In order to prepare for this important step in your professional development, I've put together a comprehensive study guide that outlines all the key learning outcomes that the exam will cover. This guide should serve as both a summary of the course content and as a revision tool for you to check your understanding.

The study guide is divided into 26 sections, starting from the very basics of what a database is, moving through different database models, discussing levels of data abstraction, the process of gathering requirements for database design, defining tables, utilizing conceptual data modeling, identifying unique identifiers, and many other key topics. As we move further into the guide, it delves into more complex topics such as resolving many-to-many relationships, tracking data changes over time, and using SQL.

In addition to understanding the theoretical knowledge, you'll also need to apply it practically by using SQL to manage data, tables, and relationships in Oracle Database. This includes writing queries, manipulating data, and managing transactions.

Lastly, the guide walks you through specific SQL operations such as SELECT statements, WHERE and ORDER BY clauses, as well as different types of table joins.

Remember, this study guide is not meant to introduce new content; rather, it is a roadmap to revising and consolidating the topics you've already studied during our course. It will remind you of the key points and give you a solid foundation to build upon as you prepare for the Oracle Certification Exam.

Studying for and achieving this certification will not only validate the knowledge and skills you've acquired throughout this course, but it will also increase your marketability as a data professional and expand your career opportunities. Whether you are looking to break into a new role or elevate your current position, the Oracle Certification can help you achieve your goals.

So, I encourage you to take full advantage of this study guide and view the upcoming Oracle Certification Exam as an opportunity to shine and demonstrate your proficiency. I'm confident in your ability to do well, and I'm here to support you as you prepare.

Best of luck in your studies!

[What is a Database?. 3](https://d.docs.live.net/a59f6868c3431710/Teaching/2023_Fall/Database/Oracle_Exam_Prep.docx#_Toc140584349)

[1: Understanding What is a Database?. 3](https://d.docs.live.net/a59f6868c3431710/Teaching/2023_Fall/Database/Oracle_Exam_Prep.docx#_Toc140584350)

[2: Describe types of database models (relational, object-oriented, flat, network...)  4](https://d.docs.live.net/a59f6868c3431710/Teaching/2023_Fall/Database/Oracle_Exam_Prep.docx#_Toc140584351)

[3: Relational Database Concepts. 4](https://d.docs.live.net/a59f6868c3431710/Teaching/2023_Fall/Database/Oracle_Exam_Prep.docx#_Toc140584352)

[4: Defining Levels of Data Abstraction. 5](https://d.docs.live.net/a59f6868c3431710/Teaching/2023_Fall/Database/Oracle_Exam_Prep.docx#_Toc140584353)

[The Language of Database and Data Modeling. 7](https://d.docs.live.net/a59f6868c3431710/Teaching/2023_Fall/Database/Oracle_Exam_Prep.docx#_Toc140584354)

[6: Defining a Table in a Database. 7](https://d.docs.live.net/a59f6868c3431710/Teaching/2023_Fall/Database/Oracle_Exam_Prep.docx#_Toc140584355)

[7: Using Conceptual Data Modeling. 7](https://d.docs.live.net/a59f6868c3431710/Teaching/2023_Fall/Database/Oracle_Exam_Prep.docx#_Toc140584356)

[8: Defining Instance and Schema in Relational Databases  8](https://d.docs.live.net/a59f6868c3431710/Teaching/2023_Fall/Database/Oracle_Exam_Prep.docx#_Toc140584357)

[9: Using Unique Identifiers, Primary and Foreign Keys. 8](https://d.docs.live.net/a59f6868c3431710/Teaching/2023_Fall/Database/Oracle_Exam_Prep.docx#_Toc140584358)

[Data Modeling -- Creating the Physical Model  9](https://d.docs.live.net/a59f6868c3431710/Teaching/2023_Fall/Database/Oracle_Exam_Prep.docx#_Toc140584359)

[10: Creating Physical Data Models. 10](https://d.docs.live.net/a59f6868c3431710/Teaching/2023_Fall/Database/Oracle_Exam_Prep.docx#_Toc140584360)

[11: Documenting Business Requirements and Rules. 10](https://d.docs.live.net/a59f6868c3431710/Teaching/2023_Fall/Database/Oracle_Exam_Prep.docx#_Toc140584361)

[12: Defining Supertype and Subtype Entity Relationships. 11](https://d.docs.live.net/a59f6868c3431710/Teaching/2023_Fall/Database/Oracle_Exam_Prep.docx#_Toc140584362)

[13: Using Attributes. 12](https://d.docs.live.net/a59f6868c3431710/Teaching/2023_Fall/Database/Oracle_Exam_Prep.docx#_Toc140584363)

[13.4: Distinguish between volatile and nonvolatile attributes. 12](https://d.docs.live.net/a59f6868c3431710/Teaching/2023_Fall/Database/Oracle_Exam_Prep.docx#_Toc140584364)

[14: Using Unique Identifiers (UIDs)  12](https://d.docs.live.net/a59f6868c3431710/Teaching/2023_Fall/Database/Oracle_Exam_Prep.docx#_Toc140584365)

[15: Identifying Relationships. 13](https://d.docs.live.net/a59f6868c3431710/Teaching/2023_Fall/Database/Oracle_Exam_Prep.docx#_Toc140584366)

[17: Identifying Hierarchical, Recursive, and Arc Relationships. 16](https://d.docs.live.net/a59f6868c3431710/Teaching/2023_Fall/Database/Oracle_Exam_Prep.docx#_Toc140584367)

[18: Tracking Data Changes Over Time. 17](https://d.docs.live.net/a59f6868c3431710/Teaching/2023_Fall/Database/Oracle_Exam_Prep.docx#_Toc140584368)

[19: Validating Data Using Normalization. 18](https://d.docs.live.net/a59f6868c3431710/Teaching/2023_Fall/Database/Oracle_Exam_Prep.docx#_Toc140584369)

[Mapping the Physical Model  19](https://d.docs.live.net/a59f6868c3431710/Teaching/2023_Fall/Database/Oracle_Exam_Prep.docx#_Toc140584370)

[21: Mapping Primary, Composite Primary, and Foreign Keys. 20](https://d.docs.live.net/a59f6868c3431710/Teaching/2023_Fall/Database/Oracle_Exam_Prep.docx#_Toc140584371)

[Introduction to SQL. 21](https://d.docs.live.net/a59f6868c3431710/Teaching/2023_Fall/Database/Oracle_Exam_Prep.docx#_Toc140584372)

[22: Using Structured Query Language (SQL)  21](https://d.docs.live.net/a59f6868c3431710/Teaching/2023_Fall/Database/Oracle_Exam_Prep.docx#_Toc140584373)

[24: Using Data Manipulation Language (DML) and Transaction Control Language (TCL)  22](https://d.docs.live.net/a59f6868c3431710/Teaching/2023_Fall/Database/Oracle_Exam_Prep.docx#_Toc140584374)

[25: Defining and Using Basic Select Statements. 23](https://d.docs.live.net/a59f6868c3431710/Teaching/2023_Fall/Database/Oracle_Exam_Prep.docx#_Toc140584375)

[26: Defining Table Joins. 24](https://d.docs.live.net/a59f6868c3431710/Teaching/2023_Fall/Database/Oracle_Exam_Prep.docx#_Toc140584376)

What is a Database?
===================\
1: Understanding What is a Database?
--------------------------------------

A database is an organized collection of data that is structured to facilitate efficient retrieval, modification, and storage operations. Databases are fundamental to many areas of technology and business, as they provide a systematic way of managing large amounts of data in a structured format.

- Remember that a database is more than just a collection of data. It's structured to allow efficient operations (like retrieval, modification, and storage).

- The information in a database can range from simple text to multimedia content.

Example: A university database might include tables for students, courses, and enrollment. Each table contains data related to a specific aspect, like students' names, course details, and which student is enrolled in which course.

### 1.1: Describe the components of a database system

A database system typically consists of the actual data, a database management system (DBMS), and the applications that interact with the data.

- A database system is composed of the actual data, the DBMS, and user applications.

- The DBMS manages interactions between the database and the applications or users. It handles data organization, storage, and security.

Example: In an e-commerce website, the product information is the data, MySQL could be the DBMS, and the website itself is the user application interacting with the database.

### 1.2: Explain the purpose of a database

The main purpose of a database is to provide a way to store and retrieve data efficiently. It ensures data consistency, integrity, and security, and provides mechanisms for concurrent access and recovery from failures.

- Databases are designed to manage data efficiently, ensuring consistency and integrity.

- They provide mechanisms for concurrent access, allowing multiple users or applications to interact with the data simultaneously without conflicts.

Example: Banks use databases to manage customer account data. They allow multiple transactions to occur at the same time (concurrent access) while ensuring the accuracy and consistency of each customer's account balance.

2: Describe types of database models (relational, object-oriented, flat, network...)
------------------------------------------------------------------------------------

There are several types of database models including the relational model, object-oriented model, flat model, network model, and others. Each model has a unique way of organizing and structuring data.

- The relational model organizes data into tables (or relations), and relationships are established using primary and foreign keys.

- Object-oriented databases organize data as objects and support inheritance, encapsulation, and polymorphism.

- Flat databases consist of a single table or list with no relation between different records.

- Example: A relational database might contain a table for "Customers" and a table for "Orders". The "Orders" table might include a "CustomerID" column, which matches the "ID" in the "Customers" table, establishing a relationship between these two tables.

### 2.1: Compare the differences between the different types of databases

Different types of databases are optimized for specific uses, based on how they structure and manage data.

- Relational databases are ideal for structured data with defined relationships, and they are commonly used in business applications.

- Object-oriented databases are good for complex data structures like those used in artificial intelligence or machine learning.

- Flat databases are simple and straightforward but lack the sophistication to handle complex data relationships.

Example: A relational database is suitable for an inventory system where data is structured and relationships between entities (like products and suppliers) are necessary, while an object-oriented database is more suitable for a computer-aided design (CAD) system where data entities have complex relationships and attributes.

3: Relational Database Concepts
-------------------------------

Relational databases are the most commonly used type of database, designed around a set of tables that are related to each other through common attributes.

### 3.1: Describe the characteristics of a relational database

Relational databases have specific characteristics that allow efficient data storage, retrieval, and management.

- Relational databases are based on the relational model, where data is organized in tables.

- Each table has a unique key (primary key) that identifies each record, and foreign keys establish relationships between tables.

Example: An "Orders" table might include a "ProductID" column. This "ProductID" is a foreign key referencing the primary key of a "Products" table, creating a relationship between the tables.

### 3.2: Explain the importance of relational databases in business

Relational databases play a crucial role in businesses due to their efficiency, flexibility, and security.

- Relational databases provide efficient data management, allowing businesses to process large volumes of data quickly.

- They support ACID (Atomicity, Consistency, Isolation, Durability) properties, ensuring data integrity and reliability, which are essential for business operations.

Example: Retail businesses use relational databases to manage their inventory, customer information, and sales data. The relationships between these data entities (products, customers, sales) help in generating insights for decision making.

### 3.3: List the major transformations in database technology

Database technology has evolved significantly over time to meet the changing needs of data storage and management.

- The transition from hierarchical and network databases to relational databases for better data accessibility and flexibility.

- The introduction of NoSQL databases (like MongoDB, Cassandra) for handling big data and real-time web applications.

- The development of NewSQL databases (like Google Spanner, CockroachDB) that aim to provide the scalability of NoSQL systems and the ACID guarantees of relational databases.

Example: The advent of cloud-based databases (like Amazon RDS, Google Cloud SQL) offers scalability and flexibility, changing how businesses handle their data storage needs.

4: Defining Levels of Data Abstraction
--------------------------------------

Database abstraction involves viewing data and structures on different levels to simplify complex database systems.

### 4.1: Define the terminology used for database storage

There are specific terms used to refer to different aspects of database storage.

- Data block: The smallest unit of data storage in a database that a single read/write operation can address.

- Table: A set of data elements that are organized using a model of vertical columns and horizontal rows.

- Index: A database structure that improves the speed of data retrieval operations on a database table.

Example: When a search is performed on a table with an index, the database uses the index (much like a book's index) to find the required data without having to search each row in the table.

### 4.2: Describe levels of data abstraction used in relational databases

Relational databases operate at three levels of data abstraction: physical, logical, and conceptual.

- Physical level: This is the lowest level of data abstraction that deals with how data is stored physically in memory. Concerns the particulars of the database management chosen (such as Oracle, SQLite, or Postgres) and the storage technology (cloud, hard drive), etc.

- Conceptual Level: This is the highest level of abstraction and it allows users to interact with the database, often in a way that is customized to their needs. Represented using ERDs.

- Note: The OracleÂ  exams contains only the "conceptual level" (everything before SQL code is written) and "physical level" (everything after).

Example: In a university database the conceptual level organization of entities and their attributes (as an ERD) would be at the conceptual level). The physical level would involve implementing this on an Oracle DBMS on some particular system (local, network, or cloud.).

### 5: Gathering Requirements for Database Design

Designing a database starts with gathering requirements. It's crucial to understand what the database will be used for, what data it will store, and how users will interact with it.

### 5.1: Gather requirements to implement a database solution

Requirements gathering is a critical first step in database design.

- Understand the scope of the database: what data it needs to store, what operations it needs to support, and who will use it.

- Identify the entities that the database will include, the attributes of these entities, and the relationships between them.

Example: If designing a database for a library, you'd need to know the different types of data to be stored (books, authors, borrowers), operations (check-out, return, reserve), and who will use the system (librarians, borrowers).

### 5.2: Explain business rules

Business rules define the operations, definitions and constraints that apply to an organization's activities.

- Business rules can affect database design by determining the structure, relationships, and constraints of the data.

- They are often derived from the policies, practices, and procedures of an organization.

Example: A business rule in a library might be that a borrower can only check out five books at a time. This would affect the design of the library database, possibly leading to a "Checkouts" table with a limit of five records per borrower.

The Language of Database and Data Modeling
==========================================

6: Defining a Table in a Database
---------------------------------

Tables are fundamental components of relational databases, storing data in a structured format.

### 6.1: Describe the structure of a single table

A table in a database has a specific structure designed to store data efficiently.

- A table is made up of columns and rows, where each column represents a specific attribute, and each row represents a record.

- Tables should include a primary key, a unique identifier for each record.

Example: In a "Customers" table, each column might represent attributes like CustomerID, Name, Address, and Phone Number. Each row would represent a single customer, and the CustomerID could be the primary key.

7: Using Conceptual Data Modeling
---------------------------------

Conceptual data modeling is a high-level representation of the data structures of an organization, showing the relationships between different entities.

### 7.1: Describe a conceptual data model

A conceptual data model provides a big-picture view of an organization's data requirements.

- It focuses on identifying the entities, their attributes, and their relationships.

- It's independent of any specific database system or technology.

- Example: For a university, a conceptual data model might include entities like Student, Course, and Department. The relationships could be Student-enrolls-in-Course, and Department-offers-Course.

### 7.2: Explain the components of a conceptual/logical model

A conceptual/logical model includes entities, relationships, and attributes.

- Entities are the main objects or concepts (like Student, Course).

- Relationships are the associations between entities (like "Student takes Course").

- Attributes are the properties or characteristics of entities (like "StudentName" for the Student entity).

Example: In a hospital database, the entities could include Patient, Doctor, and Appointment. Relationships might be "Patient sees Doctor" and "Patient has Appointment". Attributes of the Patient entity could include PatientID, Name, and Address.\
8: Defining Instance and Schema in Relational Databases
---------------------------------------------------------

In a relational database, the term "instance" refers to a specific occurrence of data, and "schema" refers to the overall structure of the database.

### 8.1: Examine examples of an entity and a corresponding table

In a relational database, an entity is represented as a table.

- An entity is an object or concept about which data is stored.

- Each instance of an entity corresponds to a row (or record) in the table.

- Example: Consider an entity "Student" in a university database. This would be represented as a table "Students" where each row represents a different student.

### 8.2: Examine examples of an attribute and a corresponding column

Attributes of an entity are represented as columns in a table.

- An attribute is a characteristic or property of an entity.

- Each attribute corresponds to a column in the table.

- Example: For the "Students" table, attributes of the "Student" entity such as "StudentID", "Name", "Major", and "GPA" would each be represented as a column in the table.

### 8.3: Explain instances and schemas in a relational database

In a relational database, an instance and a schema have specific meanings.

- An instance of a database is a snapshot of the database at a given point in time. It includes the current contents of all its tables.

- The schema of a database is the overall design of the database, including the tables, the fields in each table, and the relationships between fields and tables.

- Example: In a university database, the schema would include the design of tables like "Students", "Courses", and "Enrollments", and their relationships. An instance of the database could be the state of the database on the first day of the semester, including all the student records, course offerings, and enrollment data.

9: Using Unique Identifiers, Primary and Foreign Keys
-----------------------------------------------------

Unique identifiers, primary keys, and foreign keys are integral to defining and understanding the relationships between tables in a relational database.

### 9.1: Identify unique identifiers and a corresponding primary key

A unique identifier is an attribute or set of attributes that uniquely identifies each record in a table. This corresponds to the primary key.

- A primary key is a special relational database table column (or combination of columns) designated to uniquely identify each table record.

- Example: In a "Students" table, the "StudentID" could be a unique identifier for each student and serve as the primary key.

### 9.2: Define composite and compound primary keys

Composite and compound keys are types of primary keys that use multiple columns to create a unique identifier.

- A composite primary key consists of two or more columns that together uniquely identify each record.

- A compound primary key consists of two or more columns that are primary keys of OTHER tables (which are together a primary key for the table in question).

- Example: In a "CourseRegistrations" table, the composite key might be made up of "StudentID" and "CourseID" - no two rows could have the same combination of these values. This would also be a compound key if they were keys to other tables.

### 9.3: Define relationships and corresponding foreign keys

Foreign keys are used to establish relationships between tables in a relational database.

- A foreign key is a column or group of columns in a table that is used to establish a link between the data in two tables.

- The foreign key in one table points to the primary key in another table.

- Example: In an "Orders" table, "CustomerID" could be a foreign key linking each order to a record in the "Customers" table.

### 9.4: Define barred relationships and the corresponding primary keys

Barred relationships are a specific type of relationship used in data modeling where the unique identifier of an intersection entity comes from the originating relationships.

- In these relationships, bars are used to indicate that the primary key of the intersection entity includes foreign keys from both of the originating entities.

- The relationships from the originating entities to the intersection entity are therefore called "barred" relationships because of these bars.

- Example: Consider a "Students" entity and a "Courses" entity. If a student can enroll in multiple courses and a course can have multiple students, an intersection entity, "Enrollment", might be used to manage this many-to-many relationship. In this "Enrollment" entity, the primary key would be a composite of "StudentID" and "CourseID", both of which are foreign keys from the "Students" and "Courses" entities, respectively. The relationships from "Students" and "Courses" to "Enrollment" would be considered "barred" relationships.

Data Modeling -- Creating the Physical Model
===========================================

10: Creating Physical Data Models
---------------------------------

Physical data models represent how data is physically stored in the database, including details about the database's actual structure, such as tables, relationships, indexes, partitions, and materialized views.

### 10.1: Create a physical data model

Creating a physical data model involves transforming the logical model into a set of SQL statements that define the database's actual structure.

- Determine the tables, columns, and data types based on the logical model.

- Define the primary keys, foreign keys, and any other constraints.

- Include performance-enhancing structures like indexes, partitions, and materialized views.

- Example: An "Orders" table in the logical model might be implemented in the physical model with an Orders table having columns like OrderID (integer), CustomerID (integer), and OrderDate (date), and an index on CustomerID to enhance lookup performance.

### 10.2: Compare conceptual and physical data models

Conceptual and physical data models serve different purposes in the database design process.

A conceptual data model focuses on identifying the entities, attributes, and relationships without concern for how they'll be implemented in a specific database system.

A physical data model includes the specific implementation details for a particular database system, including table definitions, columns, data types, constraints, and performance structures.

Example: In a conceptual model, you might define a "Customer" entity with attributes and relationships. In a physical model, you'd implement this as a "Customers" table with specific columns, data types, and relationships to other tables.

11: Documenting Business Requirements and Rules
-----------------------------------------------

Clearly communicating and accurately capturing database information requirements are critical steps in designing a database that meets the needs of the business or organization.

### 11.1: Identify structural business rules

Structural business rules define the static aspects of a business, often related to how the data is organized or structured.

- They often correspond to constraints in the database schema.

- Example: A rule that each customer must have a unique customer ID corresponds to a primary key constraint on the CustomerID column in the "Customers" table.

### 11.2: Identify procedural business rules

Procedural business rules define the dynamic or operational aspects of a business, often related to processes or operations.

- They might be enforced by triggers or stored procedures in the database.

- Example: A rule that an order cannot be shipped if it hasn't been paid for might be enforced by a stored procedure that checks payment status before changing the order status to 'shipped'.

### 11.3: Identify business rules that must be enforced by additional programming (e.g., SQL)

- Some business rules might not be easily enforced by the standard database constraints and may require additional programming, typically in SQL or a similar database language.

- This could include complex validation rules, calculations, or workflows.

- Example: A rule that no more than 10% of a customer's orders can be on credit might be enforced by a custom SQL script that calculates the proportion of credit orders whenever a new order is created or an existing order is modified.

12: Defining Supertype and Subtype Entity Relationships
-------------------------------------------------------

Supertype and subtype entities are a way to model relationships between entities that share certain characteristics.

### 12.1: Describe an example of an entity

An entity is an object or concept about which data is stored.

- Entities are usually represented as tables in a relational database.

- Example: In a university database, "Student", "Course", "Instructor", "Department" are examples of entities.

### 12.2: Define supertype and subtype entities

Supertype and subtype entities represent a hierarchical relationship between entities, where subtype entities inherit characteristics from the supertype entity.

- A supertype entity has a broad scope, and its subtype entities represent more specific instances of the supertype.

- Subtypes inherit attributes and relationships from the supertype.

- Example: In a university database, "Person" could be a supertype entity with attributes like Name, Address, and Phone Number. "Student" and "Instructor" could be subtype entities of "Person", each with additional attributes relevant to students or instructors.

### 12.3: Implement rules for supertype and subtype entities

Rules for supertype and subtype entities determine how these entities interact.

- These rules often involve ensuring the integrity of the relationship, such as making sure subtype entities maintain their relationship with the supertype entity.

- Example: A rule might state that every "Student" or "Instructor" entity must also exist in the "Person" entity, reflecting the inheritance from the supertype.

13: Using Attributes
--------------------

Attributes define the characteristics or properties of an entity.

### 13.1: Describe attributes for a given entity

Attributes are specific pieces of information that we store for each entity.

- They're typically represented as columns in a table in a relational database.

- Example: For the "Student" entity, attributes might include "StudentID", "Name", "Major", and "GPA".

### 13.2: Identify and provide examples of instances

Instances are specific occurrences of an entity or an attribute.

- For an entity, an instance corresponds to a row in a table.

- For an attribute, an instance is a specific value for that attribute.

- Example: An instance of the "Student" entity might be the row for a particular student. An instance of the "Major" attribute might be the value "Computer Science".

### 13.3: Distinguish between mandatory and optional attributes

Attributes can be mandatory (required) or optional.

- A mandatory attribute must have a value for every instance of the entity.

- An optional attribute may not have a value for every instance.

- Example: In the "Student" entity, "StudentID" and "Name" might be mandatory attributes, while "Major" might be an optional attribute.

13.4: Distinguish between volatile and nonvolatile attributes
-------------------------------------------------------------

Attributes can be volatile or nonvolatile, depending on how frequently their values change.

- Volatile attributes have values that can change frequently.

- Nonvolatile attributes have values that remain constant or change very infrequently.

- Example: In the "Student" entity, "Major" might be a volatile attribute (if students change majors frequently), while "StudentID" would be a nonvolatile attribute.

14: Using Unique Identifiers (UIDs)
-----------------------------------

Unique Identifiers (UIDs) are vital in databases as they uniquely distinguish each instance of an entity.

### 14.1: Define the types of unique identifiers

There are typically two types of unique identifiers: natural and artificial.

- A natural identifier is an attribute that naturally and uniquely identifies an entity. It has meaning in the real world outside of the database.

- An artificial identifier (also known as a surrogate key) is a unique identifier that has no meaning outside of the database.

- Example: In a "Student" entity, "StudentID" could be an artificial identifier, while "Social Security Number" could be a natural identifier.

### 14.2: Select a unique identifier using business rules

Business rules, such as the need for privacy, can determine which attribute should be used as the unique identifier.

- Business rules can guide whether a natural or artificial identifier should be used.

- Example: Due to privacy concerns, the "StudentID" might be chosen as the unique identifier for the "Student" entity, rather than the "Social Security Number".

### 14.3: Define a candidate unique identifier

A candidate unique identifier is an attribute or set of attributes that could serve as the unique identifier for an entity.

- It's a potential choice for the unique identifier.

- Example: In the "Student" entity, "StudentID", "Social Security Number", and "Email" might all be candidate unique identifiers.

### 14.4: Define an artificial unique identifier

An artificial unique identifier (also known as a surrogate key) is a unique identifier that has no inherent or natural meaning, but is created solely to provide a unique identity for each record.

- These are typically system-generated, such as an incrementing integer or a GUID.

- Example: The "StudentID" in a "Student" entity might be an artificial unique identifier that is an automatically incrementing number assigned when a new student record is created.

15: Identifying Relationships
-----------------------------

Relationships in databases describe how entities are connected to each other.

### 15.1: Explain one-to-one, one-to-many, and many-to-many relationships

One-to-one, one-to-many, and many-to-many relationships are the basic types of relationships between entities.

-   One-to-one (1:1): Each instance of Entity A is related to one and only one instance of Entity B, and vice versa. For example, a "Person" is related to one and only one "Social Security Number".
-   One-to-many (1:M): Each instance of Entity A can be related to many instances of Entity B, but each instance of Entity B is related to one and only one instance of Entity A. For example, a "Teacher" can teach many "Courses", but each "Course" is taught by one "Teacher".
-   Many-to-many (M:N): Each instance of Entity A can be related to many instances of Entity B, and each instance of Entity B can be related to many instances of Entity A. For example, a "Student" can enroll in many "Courses", and each "Course" can have many "Students".

### 15.2: Identify the optionality necessary for a relationship

The optionality of a relationship determines whether an instance of an entity must participate in the relationship.

-   Mandatory relationships require every instance of an entity to be related to an instance of another entity.
-   Optional relationships allow instances of an entity to exist without a corresponding relationship.
-   For example, in a relationship between "Students" and "Courses", the relationship might be optional for "Students" (not all students are enrolled in a course) but mandatory for "Courses" (all courses must have students).

### 15.3: Identify the cardinality necessary for a relationship

Cardinality defines the numerical aspects of the relationship between two entities.

-   It defines the minimum and maximum number of instances of one entity that can relate to each instance of another entity.
-   For example, in a "Teacher"-"Course" relationship, the cardinality might be "one to many".

### 15.4: Identify nontransferable relationships

Nontransferable relationships are relationships where the child entity cannot exist without the parent entity, and the relationship to the parent entity cannot be transferred to another parent entity.

-   For example, an "Order Item" cannot exist without an "Order", and it cannot be transferred to a different "Order".

### 15.5: Name a relationship

Naming relationships is an important part of making the database design clear and understandable.

-   Relationship names should clearly indicate the nature of the relationship.
-   For example, a relationship between "Teachers" and "Courses" might be named "teaches".

### 15.6: Create ERDish sentences to represent ERDs

ERDish sentences are sentences that describe the entities and relationships in an ERD (Entity-Relationship Diagram).

-   These sentences typically follow a pattern like "[Entity A] [relationship verb] [cardinality] [Entity B]".
-   For example, an ERDish sentence might be "A 'Teacher' teaches one to many 'Courses'".

### 15.7: Create ERDs to represent ERDish sentences

Creating an ERD from an ERDish sentence involves representing the entities, relationships, cardinalities, and optionality described in the sentence.

-   For example, from the ERDish sentence "A 'Teacher' teaches one to many 'Courses'", you would create an ERD with a "Teacher" entity, a "Course" entity, and a one-to-many relationship named "teaches" from "Teacher" to "Course".

### 16: Resolving Many to Many Relationships and Composite Unique Identifiers

The resolution of many-to-many relationships and the use of composite unique identifiers are crucial in data modeling.

### 16.1: Resolve a many-to-many relationship using an intersection entity

Many-to-many (M:N) relationships are typically resolved using an intersection entity (also known as a join table, bridge entity, or associative entity).

- This intersection entity is related to the original entities via one-to-many relationships.

- Example: In a M:N relationship between "Students" and "Courses", an intersection entity called "Enrollment" could be created. Each "Enrollment" record relates one "Student" to one "Course".

### 16.2: Identify the variations of unique identifiers after creation of an intersection entity

After creating an intersection entity, unique identifiers of the original entities typically become composite unique identifiers in the intersection entity.

- The intersection entity often contains foreign keys to the original entities.

- These foreign keys, together, can form a composite unique identifier for the intersection entity.

- Example: In the "Enrollment" intersection entity, the combination of "StudentID" and "CourseID" could form a composite unique identifier.

### 16.3: Define a barred relationship

A barred relationship is a relationship between an intersection entity and the entities from which it was created, represented by bars on the relationship lines.

- The unique identifier (UID) of the intersection entity often comes from the originating relationships and is represented by the bars.

- In this case, the relationships from the originating entities to the intersection entity are called "barred" relationships.

### 16.4: Identify composite unique identifiers

A composite unique identifier is a unique identifier that consists of two or more attributes.

- Composite unique identifiers are typically used when no single attribute is unique on its own, but the combination of two or more attributes is unique.

- Example: In an "Enrollment" entity, "StudentID" and "CourseID" could together form a composite unique identifier. No two records would have the same combination of "StudentID" and "CourseID".

17: Identifying Hierarchical, Recursive, and Arc Relationships
--------------------------------------------------------------

Understanding the difference between hierarchical, recursive, and arc relationships is crucial for designing effective database structures.

### 17.1: Define a hierarchical relationship

A hierarchical relationship is one in which entities are related to each other in a parent-child structure, with each child entity having only one parent entity.

-   Example: In an organization, a "Department" entity may have many "Employees", but each "Employee" is associated with one "Department".

### 17.2: Define a recursive relationship

A recursive relationship is a relationship in which an entity is related to itself.

-   It is used when an instance of an entity has a relationship with another instance of the same entity.
-   Example: In an "Employee" entity, a "Manager" attribute might reference another "Employee" record.

### 17.3: Define an arc relationship

An arc relationship is a unique kind of relationship structure in an Entity-Relationship Diagram (ERD) in which an entity (known as the 'arc entity') is involved in relationships with two or more other entities (known as 'target entities'), but only one of those relationships can exist for each instance of the arc entity.

-   To understand this, consider an example: a "Payment" entity could have relationships to both a "Credit Card" entity and a "Bank Account" entity, but a given payment can only be made with either a credit card or a bank account, not both. This implies that for any one instance of "Payment", the relationship will only be active with either "Credit Card" or "Bank Account" and not with both at the same time. This forms an arc relationship between "Payment", "Credit Card", and "Bank Account".

### 17.4: Identify UIDs in a hierarchical, recursive, and arc relationship model

Unique Identifiers (UIDs) in different types of relationship models play different roles based on the nature of the relationship.

- Hierarchical Relationships: In these types of relationships, the UID often originates from the parent entity and is passed on to the child entities. Consider an organizational structure where a 'Department' entity is the parent, and an 'Employee' entity is the child. The UID of the 'Department' can be passed as a foreign key to the 'Employee' entity to establish a relationship between them.

- Recursive Relationships: In these relationships, an entity is related to itself. Hence, the UID is often generated within the entity itself. Consider a 'Person' entity that has a relationship 'is parent of' to another Person. The UID of the parent-Person could be used as a foreign key in the child-Person.

- Arc Relationships: In these relationships, the UID often comes from the arc entity itself and is used to identify which of the possible relationships with target entities is active for a particular instance of the arc entity. If we go back to the "Payment", "Credit Card", and "Bank Account" example, the 'PaymentID' would be the UID. Each payment would use this UID to relate to either a specific credit card or a specific bank account, but not both.

### 17.5: Construct a model using recursion and hierarchies

Building models with recursion and hierarchies involves defining the entities, relationships, and unique identifiers appropriately.

-   Recursive relationships might be represented with a foreign key within an entity that references the entity's own primary key.
-   Hierarchical relationships might be represented with an entity for each level of the hierarchy, with relationships defined between the entities.

### 17.6: Identify similarities and differences in an arc relationship and a supertype/subtype entity

Arc relationships and supertype/subtype structures both involve one entity (the 'arc entity' or 'supertype', respectively) that is related to multiple other entities (the 'target entities' or 'subtypes', respectively). However, the nature of these relationships is different in each case.

- Similarity: In both cases, the 'arc entity' or 'supertype' can potentially relate to multiple other entities ('target entities' or 'subtypes').

- Differences: Arc Relationships: In an arc relationship, an instance of the arc entity can only have an active relationship with one of the target entities at a time. For instance, an instance of a 'Payment' can relate to either a 'Credit Card' or a 'Bank Account', but not both at the same time.

- Differences: Supertype/Subtype: In a supertype/subtype relationship, an instance of the supertype can simultaneously have active relationships with multiple subtypes. For example, an 'Employee' could be a 'Manager' and a 'Sales Representative' at the same time. The 'Employee' entity is the supertype and the 'Manager' and 'Sales Representative' entities are the subtypes. Here, the employee's 'EmployeeID' (a UID from the supertype entity) can simultaneously exist in the 'Manager' and 'Sales Representative' entities, showing that this employee holds both roles.

18: Tracking Data Changes Over Time
-----------------------------------

The ability to track data changes over time is critical for accurate historical analysis and informed decision-making.

### 18.1: Explain the necessity of tracking data changes over time

Understanding and tracking data changes over time is essential for several reasons:

- It allows for historical analysis, showing how data has changed and trends have evolved.

- It enables accurate record-keeping, which is crucial for compliance and auditing purposes.

- It helps in decision-making processes by providing a context for the current data.

- Example: Tracking sales data over time can help a business understand seasonal trends, track the success of marketing campaigns, and make informed decisions about future strategies.

### 18.2: Identify data that changes over time

Certain types of data are particularly prone to changes over time and hence need careful tracking:

- Dynamic attributes such as a person's address, a product's price, or an employee's job title often change over time.

- Relationships between entities can change, like a student's enrollment in different courses, an employee's assignment to different departments, or a customer's orders over time.

### 18.3: Identify the changes in unique identifiers after adding the element of time to an ERD

The addition of the element of time to an ERD may require the adaptation of unique identifiers:

- A new attribute, such as a timestamp or date, might be added to the unique identifier to capture when a record was created or updated.

- This would create a composite unique identifier, with the original identifier and the time element together providing uniqueness.

- For example, in a "Sales" table, a sale might originally be identified by a "SaleID". But if we want to track changes over time, we might add a "Date" attribute to the unique identifier, so each sale is identified by both the "SaleID" and the "Date".\
19: Validating Data Using Normalization
=========================================

Normalization is a systematic approach of decomposing tables to eliminate data redundancy and undesirable characteristics like Insertion, Update and Deletion Anomalies. It is a multi-step process that puts data into tabular form by removing duplicated data from the relational tables.

### 19.1: Define the purpose of normalization

The primary purpose of normalization is to:

- Reduce data redundancy: This means that the same piece of data will not be stored in more than one place. This not only saves storage space but also makes the database more efficient to update.

- Eliminate anomalies: Anomalies are issues that arise in database operations due to redundancy. Normalization helps eliminate insertion, deletion, and update anomalies.

- Ensure data dependencies make sense: Normalization helps in having clear relationships among tables which further helps in understanding the database in a better way.

### 19.2: Define the rules of First, Second, and Third Normal Forms

- First Normal Form (1NF): A table is in 1NF if it contains no repeating groups of data. Each row of data must contain atomic (indivisible) values and each record needs to be unique.

- Second Normal Form (2NF): A table is in 2NF if it is in 1NF and every non-key attribute is fully functionally dependent on the primary key. This means there is no partial dependency of any column on the primary key.

- Third Normal Form (3NF): A table is in 3NF if it is in 2NF and there is no transitive dependency for non-key attributes. This means a non-key column should not depend on another non-key column.

### 19.3: Apply the rules of First, Second, and Third Normal Form

Applying these rules involves:

- For 1NF, remove any repeating groups of data by creating separate tables for each group and connect them via relationships.

- For 2NF, ensure that each non-key column is dependent on the primary key. If a column is dependent only on a part of a composite primary key, move it to a separate table.

- For 3NF, remove columns that are not dependent on the primary key but are dependent on other non-key columns. These should be placed in a separate table.

- An example: If we have a table "Orders" with columns "OrderID", "CustomerID", "CustomerName", "ProductID", "ProductName", we can apply normalization:

o 1NF: The table is already in 1NF as each column contains atomic values and each record is unique.

o 2NF: "CustomerName" is dependent on "CustomerID", not on "OrderID" (primary key). So, we create a separate "Customers" table with "CustomerID" and "CustomerName".

o 3NF: "ProductName" is dependent on "ProductID", not on "OrderID" (primary key). So, we create a separate "Products" table with "ProductID" and "ProductName".

o In the end, we have three tables "Orders", "Customers", and "Products" which are all in 3NF.

Mapping the Physical Model
==========================

### 20.1: Map entities to identify database tables to be created from an ERD

Mapping entities to tables is a key task in designing a database:

- Each entity in the ERD becomes a table in the database.

- Attributes of each entity become columns in the respective table.

- For example, an entity "Student" with attributes "StudentID", "Name", "Email" will be transformed into a table "Student" with columns "StudentID", "Name", and "Email".

### 20.2: Identify column data types from an ERD

Each attribute in an ERD will have an associated data type when it is transformed into a column in a table:

- The data type of a column determines what kind of data it can store.

- For example, the "StudentID" might be of type integer, "Name" of type varchar, and "Email" of type varchar.

### 20.3: Identify common data types used to store values in a relational database

There are several common data types used in relational databases:

- Numeric: Integer, decimal, float, etc. For example, the "Age" attribute of a "Person" entity could be stored as an integer.

- String: Char, varchar, text, etc. For example, the "Name" attribute of a "Person" entity could be stored as a varchar.

- Date and Time: Date, time, timestamp, etc. For example, the "DateOfBirth" attribute of a "Person" entity could be stored as a date.

- Binary: Blob, binary, etc. For example, the "Photo" attribute of a "Person" entity could be stored as a blob.

- Boolean: Boolean data type for true/false values. For example, the "IsEmployed" attribute of a "Person" entity could be stored as a boolean.

21: Mapping Primary, Composite Primary, and Foreign Keys
--------------------------------------------------------

Primary keys, composite primary keys, and foreign keys are essential in ensuring data integrity and establishing relationships among tables in a relational database.

### 21.1: Identify primary keys from an ERD

A primary key is an attribute or combination of attributes that uniquely identifies a record in a table:

-   In an ERD, primary keys are often highlighted or denoted with a special symbol.
-   For example, if we have an entity "Student" with attributes "StudentID", "Name", "Email", the "StudentID" would typically be the primary key as it uniquely identifies each student.

### 21.2: Identify which ERD attributes would make candidate primary keys

A candidate primary key is any attribute or set of attributes that could serve as the primary key:

-   In identifying candidate primary keys, one should consider attributes that are unique, non-null, and stable (unlikely to change).
-   For example, both "StudentID" and "Email" could be candidate primary keys in a "Student" entity, as they are likely to be unique and non-null.

### 21.3: Describe the purpose of a foreign key in an Oracle Database

A foreign key is a column or group of columns in a table that is used to establish a link between the data in two tables:

- It is a field in a table that matches the primary key of another table.

- The purpose of a foreign key is to ensure referential integrity of the data, i.e., the data in the two tables remains consistent.

### 21.4: Identify foreign keys from an ERD

Foreign keys can be identified in an ERD by looking at the relationships between entities:

- If a relationship exists between two entities, the primary key of the "parent" entity will appear as a foreign key in the "child" entity.

- For example, in a "Course Registration" entity that relates "Student" and "Course" entities, the "StudentID" and "CourseID" would be foreign keys.

### 21.5: Describe the relationship between primary keys, composite primary keys, and foreign keys in an Oracle Database

Primary keys, composite primary keys, and foreign keys all play roles in ensuring data integrity and creating relationships in a database:

- A primary key uniquely identifies a record in a table.

- A composite primary key uses multiple columns to achieve uniqueness if no single column is unique.

- A foreign key matches the primary key in another table, creating a relationship between the two tables.

- In the case of a composite primary key, the entire composite key needs to be included as a foreign key in the related table to maintain the relationship. For example, if a "Course Registration" table has a composite primary key of "StudentID" and "CourseID", both these columns would appear as foreign keys in any table that needs to reference a specific course registration.

Introduction to SQL
===================

22: Using Structured Query Language (SQL)
-----------------------------------------

Structured Query Language (SQL) is the standard language for managing and manipulating relational databases.

### 22.1: Explain the relationship between a database and SQL

SQL is the language used to interact with databases:

- SQL allows us to create, read, update, and delete records in a database.

- It is also used to manage and control access to the database.

- For example, in an Oracle database, you might use SQL to retrieve a list of customers from a "Customers" table with the query **SELECT * FROM Customers**.

### 23: Using Data Definition Language (DDL)

DDL is a subset of SQL used to define and manage structures in a database.

### 23.1: Describe the purpose of DDL

The purpose of DDL is to define and manage database objects:

- DDL includes commands like CREATE, ALTER, DROP, TRUNCATE, and RENAME.

- For example, you might use the DDL command **CREATE TABLE Customers (CustomerID INT, Name VARCHAR(100));** to create a new table in an Oracle database.

### 23.2: Use DDL to manage tables and their relationships

DDL commands are used to create and modify the structure of database tables and their relationships:

- This can include creating tables (**CREATE TABLE**), modifying existing tables (**ALTER TABLE**), deleting tables (**DROP TABLE**), and renaming tables (**RENAME**).

- In managing relationships, DDL is used to define primary keys (**PRIMARY KEY**), foreign keys (**FOREIGN KEY**), and constraints to enforce data integrity.

- For example, to add a foreign key to a "Orders" table that references the "Customers" table, you might use the DDL command **ALTER TABLE Orders ADD CONSTRAINT fk_CustomerID FOREIGN KEY (CustomerID) REFERENCES Customers(CustomerID);**.

24: Using Data Manipulation Language (DML) and Transaction Control Language (TCL)
---------------------------------------------------------------------------------

Data Manipulation Language (DML) and Transaction Control Language (TCL) are two sublanguages of SQL, with DML focused on managing data and TCL on managing transactions.

### 24.1: Describe the purpose of DML

The purpose of DML is to retrieve, insert, modify, and delete data in a database:

- DML includes commands like SELECT, INSERT, UPDATE, and DELETE.

- For example, you might use the DML command **INSERT INTO Customers (CustomerID, Name) VALUES (1, 'John Doe');** to add a new customer record to a "Customers" table in an Oracle database.

### 24.2: Use DML to manage data in tables

DML commands are used to manage the data within database tables:

- This includes retrieving data (**SELECT**), inserting new data (**INSERT**), modifying existing data (**UPDATE**), and deleting data (**DELETE**).

- For example, to modify the name of a customer in the "Customers" table, you might use the DML command **UPDATE Customers SET Name = 'Jane Doe' WHERE CustomerID = 1;**.

### 24.3: Use TCL to manage transactions

TCL commands are used to manage the changes made by DML statements:

- TCL includes commands like COMMIT, ROLLBACK, and SAVEPOINT.

- The COMMIT command is used to save the changes made in a transaction.

- The ROLLBACK command is used to undo the changes made in a transaction.

- The SAVEPOINT command is used to set a point in a transaction to which you can later rollback if needed.

- For example, if you've made several changes to a database in a single transaction, but then decide you want to undo those changes, you might use the TCL command **ROLLBACK;** to revert the database back to its state before the transaction began.\
25: Defining and Using Basic Select Statements
------------------------------------------------

Select statements form the core of data retrieval in SQL and play a crucial role in interacting with databases.

### 25.1: Identify the connection between an ERD and a Relational Database using SQL SELECT statements

The ERD (Entity Relationship Diagram) provides a visual representation of the database structure, and SQL SELECT statements query the data within that structure:

- Each entity in the ERD corresponds to a table in the database, and each attribute corresponds to a column in the table.

- A SELECT statement allows you to retrieve data from one or more of these tables.

- For example, a SELECT statement like **SELECT * FROM Customers;** corresponds to retrieving all data from the "Customers" entity in the ERD.

### 25.2: Build a SELECT statement to retrieve data from an Oracle Database table

A basic SELECT statement allows you to retrieve specific data from a table:

- The simplest form of a SELECT statement is **SELECT column_name FROM table_name;**.

- You can also use **SELECT * FROM table_name;** to select all columns from a table.

- For example, to retrieve the "Name" and "Email" columns from a "Customers" table, you might use **SELECT Name, Email FROM Customers;**.

### 25.3: Use the WHERE clause to the SELECT statement to filter query results

The WHERE clause allows you to filter the results of a SELECT statement based on one or more conditions:

- The WHERE clause follows the format SELECT column_name FROM table_name WHERE condition;.

- For example, to retrieve customers from a "Customers" table who live in "New York", you might use SELECT * FROM Customers WHERE City = 'New York';.

### 25.4: Use the ORDER BY clause to sort SQL query results

The ORDER BY clause allows you to sort the results of a SELECT statement:

- The ORDER BY clause follows the format SELECT column_name FROM table_name ORDER BY column_name [ASC|DESC];.

- For example, to retrieve customers from a "Customers" table sorted by "Name" in ascending order, you might use SELECT * FROM Customers ORDER BY Name ASC;.\
26: Defining Table Joins
--------------------------

Joins in SQL allow you to combine rows from two or more tables based on a related column between them.

### 26.1: Describe the different types of joins and their features

There are four main types of joins in SQL: INNER JOIN, LEFT JOIN (or LEFT OUTER JOIN), RIGHT JOIN (or RIGHT OUTER JOIN), and FULL JOIN (or FULL OUTER JOIN):

- **INNER JOIN**: This returns records that have matching values in both tables.

- **LEFT JOIN**: This returns all records from the left table, and the matched records from the right table. If no match is found, the result is NULL on the right side.

- **RIGHT JOIN**: This returns all records from the right table, and the matched records from the left table. If no match is found, the result is NULL on the left side.

- **FULL JOIN**: This returns all records when there is a match in either the left or the right table.

### 26.2: Use joins to retrieve data from multiple tables

Joins are used in a SELECT statement to retrieve data from multiple related tables:

-   For example, to retrieve a list of customers and their respective orders from a "Customers" table and an "Orders" table, you might use an INNER JOIN like so: **SELECT Customers.Name, Orders.OrderID FROM Customers INNER JOIN Orders ON Customers.CustomerID = Orders.CustomerID;**.
-   This would return a list of customers and their respective orders based on matching CustomerID values in both tables.
